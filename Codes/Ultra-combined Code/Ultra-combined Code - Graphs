import os
import pandas as pd
import openpyxl
import time
import logging
import matplotlib.pyplot as plt
import re  # For regular expression operations
from openpyxl import load_workbook
from openpyxl.drawing.image import Image
from io import BytesIO

# Suppress the warning messages
import warnings
warnings.filterwarnings("ignore", category=UserWarning, module="openpyxl")

# Set up logging configuration
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

def extract_first_word_and_number(sheet):
    """Extract the first word and the first four-digit number from the sheet"""
    for row in sheet.iter_rows():
        for cell in row:
            if cell.value:
                first_word = str(cell.value).split()[0]
                # Use regex to find the first four-digit number
                four_digit_number = re.search(r'\b\d{4}\b', str(cell.value))
                four_digit_number = four_digit_number.group() if four_digit_number else ""
                return first_word, four_digit_number
    return None, None

def extract_vru_headform_data(sheet):
    """Extract the data from the "VRU Headform" sheet between "PREDICTION" and "%-age"""
    prediction_cell = None
    percentage_cell = None
    for row in sheet.iter_rows():
        for cell in row:
            if cell.value == "PREDICTION":
                prediction_cell = cell
            elif cell.value == "%-age":
                percentage_cell = cell
            if prediction_cell and percentage_cell:
                break
    
    if prediction_cell and percentage_cell:
        start_row = prediction_cell.row
        start_col = prediction_cell.column
        end_col = percentage_cell.column
        data = [
            [sheet.cell(row=i, column=j).value for j in range(start_col, end_col + 1)]
            for i in range(start_row, start_row + 10)
        ]
        return data
    return None

def extract_data_from_excel(file_path):
    """Extract data from Excel files"""
    try:
        # Load the workbook and sheets
        workbook = openpyxl.load_workbook(file_path, data_only=True)
        
        # Extract the first word and number from the "OVERALL RATING" sheet
        if "OVERALL RATING" in workbook.sheetnames:
            overall_rating_sheet = workbook["OVERALL RATING"]
            first_word, four_digit_number = extract_first_word_and_number(overall_rating_sheet)
        else:
            return None, None, None

        # Extract the data from the "VRU Headform" sheet
        if "VRU Headform" in workbook.sheetnames:
            vru_headform_sheet = workbook["VRU Headform"]
            data = extract_vru_headform_data(vru_headform_sheet)
        else:
            return first_word, four_digit_number, None

        return first_word, four_digit_number, data
    except Exception as e:
        logging.error(f"Error processing {file_path}: {e}")
        return None, None, None

def generate_graphs(df, workbook, worksheet):
    """Generate scatter plots and add them to the Excel workbook"""
    # Create a sheet named 'Graphs'
    ws = workbook.create_sheet(title='Graphs')
    
    # Initial positions for the first graph
    row_position = 1
    col_position = 1
    
    # Constants to control the layout
    max_cols = 2  # Number of columns
    row_increment = 26  # Number of rows between graphs
    col_increment = 10  # Number of columns between graphs
    
    # Generate scatter plots
    for i, col in enumerate(df.columns[1:]):
        fig, ax = plt.subplots()
        scatter = ax.scatter(df[df.columns[0]], df[col], label=col, s=10, c='red')  # Set marker size to 8 and color to red
        
        # Calculate the average value for the y-axis
        avg_value = df[col].mean()
        
        # Plot the average value as a horizontal orange line
        ax.axhline(y=avg_value, color='orange', linestyle='-', label=f'Average: {avg_value:.2f}')
        
        ax.set_xlabel(df.columns[0], fontsize=10)  # Reduce x-axis label font size
        ax.set_ylabel('%-age', fontsize=10)  # Set y-axis label to '%-age'
        ax.set_title(f'{col}', fontsize=12)  # Reduce title font size
        ax.xaxis.set_tick_params(rotation=90, labelsize=6)  # Reduce x-axis label font size
        ax.yaxis.set_tick_params(labelsize=8)  # Reduce y-axis label font size
        ax.legend(fontsize=8)  # Adjust legend font size
        
        # Add data labels with 2 decimal places and offset to avoid overlapping
        for j, txt in enumerate(df[col]):
            ax.annotate(f'{txt:.2f}', (df[df.columns[0]][j], df[col][j]), 
                        fontsize=6, ha='right', 
                        xytext=(3,3), textcoords='offset points')  # Offset labels slightly
        
        # Adjust layout to make sure labels are fully visible
        plt.tight_layout()
        
        # Save plot to a BytesIO object
        img_stream = BytesIO()
        plt.savefig(img_stream, format='png', bbox_inches='tight')  # Use bbox_inches='tight' to crop extra whitespace
        plt.close(fig)
        
        # Add image to Excel in the 'Graphs' sheet
        img_stream.seek(0)
        img = Image(img_stream)
        
        # Calculate anchor position for the image
        img.anchor = ws.cell(row=row_position, column=col_position).coordinate
        ws.add_image(img)
        
        # Update row and column positions for the next graph
        if (i + 1) % max_cols == 0:
            row_position += row_increment  # Move to the next row block after filling max_cols
            col_position = 1  # Reset to the first column
        else:
            col_position += col_increment  # Move to the next column

def main():
    """Main function to extract data, generate graphs, and save results"""
    # Define the root and output directories
    root_directory = "Euro NCAP"
    output_directory = "Extracted Data/VRU Headform (UC-G) - Color-wise Data & Graphs"

    # Ensure the output directory exists
    if not os.path.exists(output_directory):
        os.makedirs(output_directory)

    # Start timing the overall execution
    start_time = time.time()

    # Data extraction timing
    extraction_start_time = time.time()

    # Iterate through each folder in the root directory
    for folder_name in os.listdir(root_directory):
        folder_path = os.path.join(root_directory, folder_name)
        
        # Ensure it's a directory
        if os.path.isdir(folder_path):
            # Initialize a DataFrame to collect all data
            combined_df = pd.DataFrame()

            # Placeholder for column names
            column_names = ["Car Names"]

            # Walk through the directory tree within the folder
            for subdir, dirs, files in os.walk(folder_path):
                for file in files:
                    if file.endswith('.xlsx') or file.endswith('.xls'):
                        file_path = os.path.join(subdir, file)
                        first_word, four_digit_number, data = extract_data_from_excel(file_path)
                        if first_word and data:
                            if four_digit_number:
                                file_name_prefix = f"{first_word} {four_digit_number}"
                            else:
                                file_name_prefix = first_word

                            df = pd.DataFrame(data)
                            if not df.empty:
                                df.columns = df.iloc[0]
                                df = df[1:]
                                df = df.dropna(how='all').dropna(axis=1, how='all')
                                
                                # Capture the values from the second column of the extracted table
                                if len(column_names) == 1 and len(df.columns) > 1:
                                    column_names.extend(df.iloc[:, 1].tolist())
                                column_names[-1] = "Predicted headform score (excluding blue points)"
                                
                                # Multiply by 100 and round to 2 decimal places
                                df.iloc[:, -1] = df.iloc[:, -1].apply(lambda x: (x * 100) if pd.notna(x) else x)
                                
                                # Append the first word and the last column of the extracted table as a new row
                                new_row = [file_name_prefix] + df.iloc[:, -1].tolist()
                                combined_df = pd.concat([combined_df, pd.DataFrame([new_row])], ignore_index=True)

            # Remove duplicate rows
            combined_df = combined_df.drop_duplicates()

            # Print the combined DataFrame before saving to Excel
            if not combined_df.empty:
                if len(column_names) < combined_df.shape[1]:
                    # Extend column names with default names if not enough provided
                    column_names.extend([f"Column {i+1}" for i in range(len(column_names), combined_df.shape[1])])
                combined_df.columns = column_names[:combined_df.shape[1]]  # Ensure exact match

                # Save the combined data to the "Data" sheet
                output_file = os.path.join(output_directory, f"{folder_name}_cars_combined.xlsx")
                with pd.ExcelWriter(output_file, engine='openpyxl') as writer:
                    combined_df.to_excel(writer, sheet_name="Data", index=False)

                    # Adjust column widths
                    workbook = writer.book
                    worksheet = writer.sheets["Data"]
                    for col in worksheet.columns:
                        max_length = 0
                        column = col[0].column_letter  # Get the column name
                        for cell in col:
                            try:
                                if len(str(cell.value)) > max_length:
                                    max_length = len(cell.value)
                            except:
                                pass
                        adjusted_width = (max_length + 2)
                        worksheet.column_dimensions[column].width = adjusted_width

                    # Generate graphs immediately after the "Data" sheet creation
                    generate_graphs(combined_df, workbook, worksheet)

            logging.info(f"\n\nData extraction complete for {folder_name}. \n\nResults saved in {output_file}.")

    # Data extraction timing
    extraction_end_time = time.time()
    extraction_execution_time = extraction_end_time - extraction_start_time
    print("\n")
    logging.info(f"\nData extraction completed in {extraction_execution_time:.2f} seconds.")

    # Total execution time
    total_execution_time = time.time() - start_time
    print("\n")
    logging.info(f"\nTotal script execution time: {total_execution_time:.2f} seconds.\n")

if __name__ == "__main__":
    main()
